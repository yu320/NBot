å¥½çš„ï¼Œé€™æ˜¯ä¸€ä»½ç‚ºæ‚¨çš„ NBot å°ˆæ¡ˆé‡èº«æ‰“é€ çš„**çµ‚æ¥µé–‹ç™¼æŒ‡å—**ã€‚


1.  **å¦‚ä½•æ ¹çµ• `.png` ä¸­çš„å¤šé‡éŒ¯èª¤è¨Šæ¯** (æ³¨æ„äº‹é … 1)ã€‚
2.  **å¦‚ä½•æ­£ç¢ºå»ºç«‹ `HybridCommand` (æ··åˆæŒ‡ä»¤)**ï¼ŒåŒ…å« `#` (å…¬é–‹) èˆ‡ `/` (ç§äºº) çš„å›è¦†SOP (æ³¨æ„äº‹é … 2)ã€‚
3.  **å¦‚ä½•ä¿®æ­£ `/monitor` ç„¡æ³•é¡¯ç¤ºçš„ `AttributeError`** (æ³¨æ„äº‹é … 2 - ç¯„ä¾‹ D)ã€‚
4.  **å¦‚ä½•å°‡èˆŠç¨‹å¼ç¢¼é·ç§»åˆ°æ–°æ¨™æº–** (æ³¨æ„äº‹é … 3)ã€‚
5.  **æ‚¨è¦æ±‚çš„æ–°åŠŸèƒ½ç¯„ä¾‹**ï¼šå¦‚ä½•è®€å– JSON (ä¾‹å¦‚ FAQ) (æ³¨æ„äº‹é … 4)ã€‚
6.  **æ‚¨è¦æ±‚çš„æ–°åŠŸèƒ½ç¯„ä¾‹**ï¼šå¦‚ä½•å»ºç«‹é—œéµå­—è‡ªå‹•å›æ‡‰ (åŒ…å«æ–‡å­—ã€è¡¨æƒ…ç¬¦è™Ÿã€åœ–ç‰‡) (æ³¨æ„äº‹é … 5)ã€‚



-----

# NBot (å®¿å®¿å¥½å¹«æ‰‹) å”ä½œé–‹ç™¼æŒ‡å— V3.2 (æœ€çµ‚å®Œæ•´ç‰ˆ)

æ­¡è¿åŠ å…¥ NBot çš„é–‹ç™¼ï¼ç‚ºç¢ºä¿ç¨‹å¼ç¢¼å“è³ªä¸€è‡´ï¼Œä¸¦é¿å…å…ˆå‰é‡åˆ°çš„ã€Œé‡è¤‡éŒ¯èª¤å›è¦†ã€å’Œã€ŒæŒ‡ä»¤å›è¦†æ··äº‚ã€å•é¡Œï¼Œè«‹æ‰€æœ‰å”ä½œè€…éµå®ˆä»¥ä¸‹æ ¸å¿ƒæŒ‡å—ã€‚

## â­ï¸ æ ¸å¿ƒåŸå‰‡

1.  **Cogs ç¨ç«‹ (æœ€é‡è¦)**ï¼šæ¯å€‹ Cog (åŠŸèƒ½æ¨¡çµ„) **çµ•å°ä¸èƒ½**è™•ç†ä¸å±¬æ–¼è‡ªå·±çš„éŒ¯èª¤ã€‚
2.  **Hybrid å„ªå…ˆ**ï¼šæ‰€æœ‰æŒ‡ä»¤**å¿…é ˆ**ä½¿ç”¨ã€Œæ··åˆæŒ‡ä»¤ã€(`Hybrid Command`)ï¼Œä»¥åŒæ™‚æ”¯æ´ `#` (å‰ç¶´) å’Œ `/` (æ–œç·š)ã€‚
3.  **å‹•æ…‹å›è¦† (SOP)**ï¼šæ‰€æœ‰å›è¦†**å¿…é ˆ**éµå®ˆã€Œ`/` ç§äºº, `#` å…¬é–‹ã€çš„åŸå‰‡ã€‚

-----

## âš ï¸ æ³¨æ„äº‹é … 1ï¼šã€å¿…è®€ã€‘å¦‚ä½•æ ¹çµ•ã€Œå¤šé‡/é‡è¤‡éŒ¯èª¤è¨Šæ¯ã€

**å•é¡Œ**ï¼šç•¶ `#addevent` å‡ºéŒ¯æ™‚ï¼Œ`calendar.py` çš„éŒ¯èª¤ç›£è½å™¨æœƒå•Ÿå‹•ï¼Œ**ä½† `main.py`, `musiclist.py`, `music_play.py` çš„ç›£è½å™¨ä¹Ÿæœƒè¢«è§¸ç™¼**ã€‚å®ƒå€‘ç™¼ç¾ `addevent` ä¸å±¬æ–¼è‡ªå·±ï¼Œå°±é€²å…¥ `else` å€å¡Šï¼Œå‘¼å«äº† `bot.py` çš„å…¨åŸŸéŒ¯èª¤è™•ç†å™¨ï¼Œå°è‡´æ‚¨çœ‹åˆ°ä¸€å †ã€ŒæœªçŸ¥çš„å…§éƒ¨éŒ¯èª¤ã€ã€‚

**è¦å‰‡**ï¼š**æ‰€æœ‰** `cmds/` è³‡æ–™å¤¾ä¸­çš„ `on_command_error` å‡½å¼ï¼Œéƒ½**å¿…é ˆ**ä½¿ç”¨ä»¥ä¸‹ç¯„æœ¬ã€‚

é€™**æ˜¯ `.png` éŒ¯èª¤çš„**ä¸»å› \*\*ã€‚

**å•é¡Œåˆ†æ**ï¼š
ç•¶ä¸€å€‹æŒ‡ä»¤ï¼ˆå¦‚ `#addevent`ï¼‰å‡ºéŒ¯æ™‚ï¼Œ**æ‰€æœ‰**çš„ Cogs æª”æ¡ˆï¼ˆ`main.py`, `calendar.py`, `music.py`...ï¼‰ä¸­çš„ `on_command_error` ç›£è½å™¨**éƒ½æœƒè¢«è§¸ç™¼**ã€‚

  * `calendar.py` ç™¼ç¾æ˜¯è‡ªå·±çš„éŒ¯ï¼Œæ–¼æ˜¯å›è¦†äº†ã€Œâš ï¸ åƒæ•¸éºæ¼éŒ¯èª¤ã€ã€‚
  * ä½† `main.py` ç™¼ç¾é€™**ä¸æ˜¯** `ping` æˆ– `clean`ï¼Œæ–¼æ˜¯å®ƒé€²å…¥äº† `else` å€å¡Šã€‚
  * é€™å€‹ `else` å€å¡Šï¼ˆæ‚¨æŒ‡å‡ºçš„ `self.bot.on_command_error(ctx, error)`ï¼‰æœƒ**æ‰‹å‹•å°‡éŒ¯èª¤å†æ¬¡ä¸Ÿçµ¦ `bot.py`** çš„å…¨åŸŸéŒ¯èª¤è™•ç†å™¨ã€‚
  * çµæœï¼š`bot.py` æ”¶åˆ°äº†ä¾†è‡ª `main.py`, `musiclist.py`, `music_play.py` ç­‰**å¤šå€‹ Cog** ä¸Ÿä¸Šä¾†çš„åŒä¸€å€‹éŒ¯èª¤ï¼Œå°è‡´æ‚¨çœ‹åˆ°**æ•¸æ¬¡çš„**ã€ŒâŒ ç™¼ç”Ÿäº†ä¸€å€‹æœªçŸ¥çš„å…§éƒ¨éŒ¯èª¤ã€ã€‚

**è§£æ±ºæ–¹æ¡ˆ**ï¼š
**æ‰€æœ‰** Cogs çš„ `on_command_error` å‡½å¼ï¼Œéƒ½**å¿…é ˆ**åœ¨é–‹é ­åŠ å…¥ã€ŒCog åç¨±æª¢æŸ¥ã€ï¼Œä¸¦ä¸”**å¿…é ˆåˆªé™¤**é‚£å€‹ `else` å€å¡Šã€‚

### âœ… æ­£ç¢ºçš„ `on_command_error` ç¯„æœ¬ (é©ç”¨æ‰€æœ‰ Cogs)

```python
    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        
        # âœ… 1. é—œéµä¿®æ­£ï¼šæª¢æŸ¥æ­¤éŒ¯èª¤æ˜¯å¦ä¾†è‡ªæœ¬ Cog
        # (å°‡ 'MyCogName' æ›¿æ›ç‚ºè©² class çš„åç¨±, ä¾‹å¦‚ 'Main', 'Calendar', 'MusicPlay')
        if ctx.command and ctx.command.cog_name != 'MyCogName':
            return # éŒ¯èª¤ä¸å±¬æ–¼æˆ‘ï¼Œç«‹åˆ»é€€å‡ºï¼Œä¸è™•ç†

        # (æ—¥èªŒåªæœƒè¨˜éŒ„æœ¬ Cog çš„éŒ¯èª¤)
        logging.warning(f"MyCogName Cog æ•ç²åˆ°æŒ‡ä»¤éŒ¯èª¤ (æŒ‡ä»¤: {ctx.command}, éŒ¯èª¤: {error})")

        # âœ… 2. æª¢æŸ¥æ˜¯å¦ç‚ºç§äººå›è¦†
        is_private = ctx.interaction is not None
        
        # âœ… 3. è™•ç†æœ¬ Cog è‡ªå·±çš„éŒ¯èª¤ (ä¾‹å¦‚ 'play' æŒ‡ä»¤)
        if ctx.command and ctx.command.name in ['play', 'p']:
            
            # --- è™•ç†ã€Œéºæ¼åƒæ•¸ã€ ---
            if isinstance(error, commands.MissingRequiredArgument):
                # (ä¿ç•™æ‚¨è¦çš„å®Œæ•´ç¯„ä¾‹)
                await ctx.send(
                    f"âš ï¸ **æ‚¨å¿˜è¨˜æä¾›æ­Œæ›²åç¨±æˆ–é€£çµäº†ï¼**\n\n"
                    f"**ğŸ‘‰ æ­£ç¢ºæ ¼å¼ï¼š**\n"
                    f"`{ctx.prefix}{ctx.command.name} [YouTube é—œéµå­—æˆ– URL]`\n"
                    f"**ç¯„ä¾‹ï¼š** `{ctx.prefix}{ctx.command.name} Never Gonna Give You Up`",
                    ephemeral=is_private # âœ… ä½¿ç”¨å‹•æ…‹å›è¦†
                )
            
            # --- è™•ç†ã€Œæ¬Šé™ä¸è¶³ã€ ---
            elif isinstance(error, commands.MissingPermissions):
                await ctx.send("âŒ **æ¬Šé™ä¸è¶³ï¼š** æ‚¨æ²’æœ‰æ¬Šé™åŸ·è¡Œæ­¤æŒ‡ä»¤ã€‚", ephemeral=is_private, delete_after=10)

            # --- è™•ç†ã€Œåƒæ•¸é¡å‹éŒ¯èª¤ã€ ---
            elif isinstance(error, commands.BadArgument):
                 await ctx.send(f"âš ï¸ **åƒæ•¸é¡å‹éŒ¯èª¤ï¼š** æ‚¨è¼¸å…¥çš„ `{error.param.name}` æ ¼å¼ä¸å°ã€‚", ephemeral=is_private)
            
            else:
                # âœ… 4. å¦‚æœæ˜¯æœ¬ Cog çš„éŒ¯èª¤ï¼Œä½†ä½ ä¸æƒ³è™•ç† (ä¾‹å¦‚ Cooldown)
                # ä»€éº¼éƒ½ä¸åš (pass)ï¼Œè®“å®ƒè‡ªå‹•ä¸Šå ±çµ¦ bot.py çš„å…¨åŸŸè™•ç†å™¨ (åªæœƒå ±éŒ¯ä¸€æ¬¡)
                pass
        
        # âœ… 5. çµ•å°ç¦æ­¢ï¼šåˆªé™¤æ—§çš„ 'else' å€å¡Š
        # 
        # (âŒ éŒ¯èª¤çš„å¯«æ³• - å¿…é ˆåˆªé™¤):
        # else:
        #     if self.bot.extra_events.get('on_command_error', None) is not None:
        #          await self.bot.on_command_error(ctx, error)
        #     else:
        #          logging.error(f"Unhandled error in {ctx.command}: {error}")
```

-----

## âš ï¸ æ³¨æ„äº‹é … 2ï¼šå¦‚ä½•æ­£ç¢ºæ’°å¯«ã€ŒHybrid æ··åˆæŒ‡ä»¤ã€

æˆ‘å€‘å¿…é ˆ**åŒæ™‚æ”¯æ´** `#` (å…¬é–‹) å’Œ `/` (ç§äºº)ã€‚

### âœ… ç¯„ä¾‹ Aï¼šç°¡å–®æŒ‡ä»¤ (ç«‹å³å›è¦†)

é©ç”¨æ–¼ `ping`, `list`, `queue` ç­‰èƒ½ã€Œç«‹å³ã€å›è¦†çš„æŒ‡ä»¤ã€‚

```python
    @commands.hybrid_command(
        name="ping", 
        description="æ¸¬è©¦æ©Ÿå™¨äººçš„å»¶é² (ms)" # / æŒ‡ä»¤çš„èªªæ˜
    )
    async def ping(self, ctx: commands.Context):
        """æ¸¬è©¦æ©Ÿå™¨äººçš„å»¶é² (ms)""" # # æŒ‡ä»¤çš„èªªæ˜
        
        # 1. æª¢æŸ¥æŒ‡ä»¤æ˜¯å¦‚ä½•è¢«å‘¼å«çš„
        is_private = ctx.interaction is not None

        # 2. å°‡ is_private å‚³å…¥ ephemeral åƒæ•¸
        await ctx.send(f'{round(self.bot.latency*1000)} (ms)', ephemeral=is_private)
```

### âœ… ç¯„ä¾‹ Bï¼šå¸¶æœ‰ã€Œå¯é¸åƒæ•¸ã€çš„æŒ‡ä»¤

é©ç”¨æ–¼ `musiclist` (é ç¢¼å¯é¸)ã€‚

```python
    @commands.hybrid_command(
        name='musiclist', 
        aliases=['éŸ³æ¨‚æ¸…å–®', 'æ¸…å–®'], 
        description="é¡¯ç¤ºå·²è¨˜éŒ„çš„éŸ³æ¨‚æ¸…å–® (ä½¿ç”¨æŒ‰éˆ•åˆ†é )"
    )
    # âœ… æ›¿ / æŒ‡ä»¤çš„ã€Œå¯é¸åƒæ•¸ã€åŠ ä¸Šèªªæ˜
    @app_commands.describe(
        page="è¦é¡¯ç¤ºçš„é ç¢¼ (é è¨­ 1)"
    )
    async def show_music_list(self, ctx: commands.Context, page: int = 1):
        """
        é¡¯ç¤ºå·²è¨˜éŒ„çš„éŸ³æ¨‚æ¸…å–®ï¼Œæ¯é 10ç­†ï¼Œä½¿ç”¨æŒ‰éˆ•åˆ†é ã€‚
        æŒ‡ä»¤æ ¼å¼: #musiclist [é ç¢¼]
        """
        is_private = ctx.interaction is not None
        
        # ... åŸ·è¡Œä½ çš„ç¨‹å¼é‚è¼¯ ...
        embed = discord.Embed(title=f"é¡¯ç¤ºç¬¬ {page} é ")
        
        await ctx.send(embed=embed, ephemeral=is_private)
```

### âœ… ç¯„ä¾‹ Cï¼šè€—æ™‚æŒ‡ä»¤ (éœ€è¦ã€Œæ€è€ƒä¸­...ã€çš„å›è¦†)

**é€™æ˜¯æœ€é‡è¦ã€ä¹Ÿæœ€è¤‡é›œçš„æ¨¡å¼ã€‚** é©ç”¨æ–¼ `play`, `calendar`, `importmusic` ç­‰éœ€è¦ã€ŒAPI è«‹æ±‚ã€çˆ¬èŸ²ã€è®€å–æª”æ¡ˆã€çš„æŒ‡ä»¤ã€‚

```python
    @commands.hybrid_command(
        name='addevent', 
        description="æ–°å¢ä¸€å€‹ Google æ—¥æ›†æ´»å‹•"
    )
    @app_commands.describe(
        date_time="æ—¥æœŸèˆ‡æ™‚é–“ (æ ¼å¼: \"YYYY-MM-DD [HH:MM]\")",
        title="æ´»å‹•æ¨™é¡Œ (æ ¼å¼: \"æˆ‘çš„æ¨™é¡Œ\")"
    )
    async def add_calendar_event(self, ctx: commands.Context, date_time: str, title: str):
        """æ–°å¢ä¸€å€‹ Google æ—¥æ›†æ´»å‹•"""

        # 1. æª¢æŸ¥æŒ‡ä»¤æ˜¯å¦‚ä½•è¢«å‘¼å«çš„
        is_private = ctx.interaction is not None

        # 2. ç™¼é€ã€Œæ­£åœ¨è™•ç†ã€è¨Šæ¯
        # ( / æŒ‡ä»¤æœƒè‡ªå‹•é¡¯ç¤º "Bot æ­£åœ¨æ€è€ƒ...")
        # ( # æŒ‡ä»¤æœƒç™¼é€ä¸€å‰‡ "æ­£åœ¨æ–°å¢..." çš„å…¬é–‹è¨Šæ¯)
        original_message = await ctx.send(f"æ­£åœ¨å‘ Google Calendar æ–°å¢æ´»å‹• `{title}`...", ephemeral=is_private)

        try:
            # 3. ... (åŸ·è¡Œæ‚¨çš„è€—æ™‚ä»»å‹™, ä¾‹å¦‚ requests.post) ...
            await asyncio.sleep(5) # æ¨¡æ“¬è€—æ™‚
            
            # 4. æº–å‚™æœ€çµ‚çš„å›è¦†å…§å®¹
            response_content = f"âœ… æˆåŠŸæ–°å¢æ´»å‹•ï¼š{title}"

        except Exception as e:
            response_content = f"âŒ ç™¼ç”ŸéŒ¯èª¤: {e}"

        # 5. æ ¹æ“šå‘¼å«é¡å‹ï¼Œæ±ºå®šå¦‚ä½•ã€Œæ›´æ–°ã€è¨Šæ¯
        if is_private:
            # âœ… / æŒ‡ä»¤ï¼šå¿…é ˆä½¿ç”¨ followup.send ä¾†ã€Œç·¨è¼¯ã€æ€è€ƒä¸­è¨Šæ¯
            await ctx.followup.send(response_content, ephemeral=True)
        else:
            # âœ… # æŒ‡ä»¤ï¼šå¿…é ˆä½¿ç”¨ .edit() ä¾†ã€Œç·¨è¼¯ã€åŸå§‹çš„å…¬é–‹è¨Šæ¯
            await original_message.edit(content=response_content)
```

### âœ… ç¯„ä¾‹ Dï¼šæŒ‡ä»¤ç¾¤çµ„ (Groups)

ç”¨æ–¼ `/monitor` é€™é¡æ“æœ‰å¤šå€‹å­æŒ‡ä»¤çš„åŠŸèƒ½ã€‚**é€™æ˜¯ä¿®æ­£ `AttributeError` éŒ¯èª¤çš„æ­£ç¢ºæ–¹æ³•**ã€‚

```python
    # 1. å»ºç«‹ä¸»æŒ‡ä»¤ (å¿…é ˆä½¿ç”¨ hybrid_group)
    @commands.hybrid_group(
        name='monitor', 
        aliases=['ç›£æ¸¬', 'èª²è¡¨ç›£æ¸¬'], 
        description="ç®¡ç†èª²ç¨‹äººæ•¸ç›£æ¸¬ä»»å‹™"
    )
    async def monitor(self, ctx: commands.Context):
        """ç®¡ç†èª²ç¨‹äººæ•¸ç›£æ¸¬ä»»å‹™ã€‚"""
        
        is_private = ctx.interaction is not None
        
        # é€™æ˜¯ç•¶ä½¿ç”¨è€…åªè¼¸å…¥ /monitor æˆ– #monitor æ™‚çš„å›è¦†
        if ctx.invoked_subcommand is None:
            embed = discord.Embed(title="ğŸ“š èª²ç¨‹äººæ•¸ç›£æ¸¬ç®¡ç†")
            embed.add_field(name="ç”¨æ³•", value=f"`{ctx.prefix}monitor add` æˆ– `/monitor add`")
            await ctx.send(embed=embed, ephemeral=is_private)

    # âœ… 2. å»ºç«‹å­æŒ‡ä»¤ (å¿…é ˆä½¿ç”¨ @monitor.commandï¼Œä¸æ˜¯ .hybrid_command)
    @monitor.command(
        name='add', 
        aliases=['æ–°å¢'], 
        description="[äº’å‹•å¼] æ–°å¢ä¸€å€‹èª²ç¨‹äººæ•¸ç›£æ¸¬ä»»å‹™"
    )
    @commands.has_permissions(manage_roles=True) 
    async def add_monitor_job(self, ctx: commands.Context):
        is_private = ctx.interaction is not None
        await ctx.send("æ­£åœ¨æ–°å¢ä»»å‹™...", ephemeral=is_private)
        # ... (ä½¿ç”¨ followup æˆ– edit ä¾†å›è¦†çµæœ) ...

    # âœ… 3. å»ºç«‹å¦ä¸€å€‹å¸¶æœ‰åƒæ•¸çš„å­æŒ‡ä»¤ (å¿…é ˆä½¿ç”¨ @monitor.command)
    @monitor.command(
        name='remove', 
        aliases=['ç§»é™¤', 'åˆªé™¤'], 
        description="ç§»é™¤ä¸€å€‹èª²ç¨‹äººæ•¸ç›£æ¸¬ä»»å‹™"
    )
    @app_commands.describe(course_id="è¦ç§»é™¤çš„èª²è™Ÿ")
    @commands.has_permissions(manage_roles=True) 
    async def remove_monitor_job(self, ctx: commands.Context, course_id: str):
        is_private = ctx.interaction is not None
        await ctx.send(f"å·²ç§»é™¤ {course_id}", ephemeral=is_private)
```

-----

## âš ï¸ æ³¨æ„äº‹é … 3ï¼šã€æ–°ã€‘å¦‚ä½•å°‡ã€ŒèˆŠæŒ‡ä»¤ã€å‡ç´šç‚ºã€Œæ–° Hybrid æŒ‡ä»¤ã€

é€™è£å±•ç¤ºäº†å°‡ä¸€å€‹èˆŠçš„ã€è¤‡é›œçš„æŒ‡ä»¤ï¼ˆå¦‚ `cmds/calendar.py`ï¼‰é·ç§»åˆ°æ–°æ¨™æº–çš„**å®Œæ•´å·®ç•°**ã€‚

### 1\. é·ç§»æŒ‡ä»¤æœ¬èº« (`addevent`)

```python
# ---------------------------------
# âŒ èˆŠçš„å¯«æ³• (Before)
# ---------------------------------
import discord
from discord.ext import commands
# ( ... å…¶ä»– import ... )

class Calendar(commands.Cog):
    # ...
    
    @commands.command(name='addevent', aliases=[...])
    async def add_calendar_event(self, ctx, date_time: str, title: str, duration: int = 60, calendar_key: str = "default"):
        
        # ğŸ› å•é¡Œé»ï¼šç¸½æ˜¯å…¬é–‹å›è¦†
        await ctx.send(f"æ­£åœ¨å‘ Google Calendar æ–°å¢æ´»å‹• `{title}`...") 

        try:
            r = await asyncio.to_thread(requests.post, ...)
            
            gas_response = r.json()
            if gas_response.get("status") == "success":
                message = gas_response.get("message")
                link = gas_response.get("link")
                
                # ğŸ› å•é¡Œé»ï¼šåˆä¸€æ¬¡ ctx.sendï¼Œå°è‡´å¤šå‰‡å…¬é–‹å›è¦†
                if link:
                    await ctx.send(f"{message}\n[ğŸ”— æŸ¥çœ‹æ—¥æ›†æ´»å‹•]({link})")
                else:
                    await ctx.send(f"{message}")
            else:
                await ctx.send("âŒ æ—¥æ›† API è™•ç†å¤±æ•—...")
        
        except Exception as e:
            await ctx.send(f"âŒ ç™¼ç”Ÿç¨‹å¼ç¢¼éŒ¯èª¤: {e}")

```

```python
# ---------------------------------
# âœ… æ–°çš„å¯«æ³• (After)
# ---------------------------------
import discord
from discord.ext import commands
from discord import app_commands # âœ… 1. å¼•å…¥ app_commands
# ( ... å…¶ä»– import ... )

class Calendar(Cog_Extension): # âœ… (ä½¿ç”¨ä½ çš„ Cog_Extension)
    # ...
    
    @commands.hybrid_command(name='addevent', aliases=[...], description="æ–°å¢ä¸€å€‹ Google æ—¥æ›†æ´»å‹•...") # âœ… 2. æ”¹ç‚º hybrid_command
    @app_commands.describe( # âœ… 3. ç‚º / æŒ‡ä»¤æ–°å¢åƒæ•¸èªªæ˜
        date_time="æ—¥æœŸèˆ‡æ™‚é–“ (æ ¼å¼: \"...\")",
        title="æ´»å‹•æ¨™é¡Œ (æ ¼å¼: \"...\")",
        duration="æŒçºŒæ™‚é–“ (åˆ†é˜) (é è¨­ 60)",
        calendar_key="æ—¥æ›†ä»£è™Ÿ (é è¨­ default)"
    )
    async def add_calendar_event(self, ctx: commands.Context, date_time: str, title: str, duration: int = 60, calendar_key: str = "default"):
        
        is_private = ctx.interaction is not None # âœ… 4. æª¢æŸ¥å‘¼å«æ–¹å¼

        # âœ… 5. ç™¼é€ã€Œæ€è€ƒä¸­ã€è¨Šæ¯ (ä¸¦å„²å­˜å®ƒ)
        original_message = await ctx.send(f"æ­£åœ¨å‘ Google Calendar æ–°å¢æ´»å‹• `{title}`...", ephemeral=is_private)

        try:
            r = await asyncio.to_thread(requests.post, ...)
            
            # âœ… 6. æº–å‚™ã€Œå–®ä¸€ã€çš„å›è¦†å…§å®¹
            response_content = ""
            if r.status_code == 200:
                gas_response = r.json()
                if gas_response.get("status") == "success":
                    message = gas_response.get("message")
                    link = gas_response.get("link")
                    # (ä½¿ç”¨ä¸‰å…ƒé‹ç®—å­ï¼Œç¢ºä¿ link æª¢æŸ¥ä¾ç„¶å­˜åœ¨)
                    response_content = f"{message}" + (f"\n[ğŸ”— æŸ¥çœ‹æ—¥æ›†æ´»å‹•]({link})" if link else "")
                else:
                    response_content = "âŒ æ—¥æ›† API è™•ç†å¤±æ•—..."
            else:
                response_content = f"âŒ ç¶²è·¯è«‹æ±‚å¤±æ•—ï¼š{r.status_code}"
        
        except Exception as e:
            response_content = f"âŒ ç™¼ç”Ÿç¨‹å¼ç¢¼éŒ¯èª¤: {e}"

        # âœ… 7. æ ¹æ“šå‘¼å«æ–¹å¼ï¼Œç”¨ã€Œä¸€ç¨®ã€æ–¹å¼å›è¦†
        if is_private:
            await ctx.followup.send(response_content, ephemeral=True) # / æŒ‡ä»¤ç”¨ followup
        else:
            await original_message.edit(content=response_content) # # æŒ‡ä»¤ç”¨ edit
```

### 2\. é·ç§»éŒ¯èª¤è™•ç† (`on_command_error`)

é€™æ˜¯ä¿®å¾© `image_5d586b.png` å•é¡Œçš„**é—œéµ**ã€‚

```python
# ---------------------------------
# âŒ èˆŠçš„å¯«æ³• (Before) - å°è‡´é‡è¤‡éŒ¯èª¤
# ---------------------------------
    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        
        if ctx.command and ctx.command.name in ['addevent', ...]:
            
            if isinstance(error, commands.MissingRequiredArgument):
                await ctx.send(f"âš ï¸ åƒæ•¸éºæ¼éŒ¯èª¤...")
            
        else:
            # âŒ é€™è£¡æ˜¯å…ƒå…‡ï¼
            if self.bot.extra_events.get('on_command_error', None) is not None:
                 await self.bot.on_command_error(ctx, error)
```

```python
# ---------------------------------
# âœ… æ–°çš„å¯«æ³• (After) - å·²ä¿®æ­£
# ---------------------------------
    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        
        # âœ… 1. åŠ å…¥ Cog æª¢æŸ¥
        if ctx.command and ctx.command.cog_name != 'Calendar':
            return # ä¸å±¬æ–¼æˆ‘ï¼Œç«‹åˆ»é€€å‡º

        logging.warning(f"Calendar Cog æ•ç²åˆ°æŒ‡ä»¤éŒ¯èª¤ (æŒ‡ä»¤: {ctx.command}, éŒ¯èª¤: {error})")

        # âœ… 2. æª¢æŸ¥ç§äººå›è¦†
        is_private = ctx.interaction is not None

        if ctx.command and ctx.command.name in ['addevent', ...]:
            
            if isinstance(error, commands.MissingRequiredArgument):
                await ctx.send(
                    f"âš ï¸ åƒæ•¸éºæ¼éŒ¯èª¤...(ç¯„ä¾‹)...", # (ä¿ç•™æ‚¨çš„å®Œæ•´éŒ¯èª¤ç¯„æœ¬)
                    ephemeral=is_private # âœ… 3. åŠ å…¥å‹•æ…‹å›è¦†
                )
            
            else:
                pass # ä¸Šå ±çµ¦ bot.py
        
        # âœ… 4. åˆªé™¤ 'else' å€å¡Š
```

-----

## âš ï¸ æ³¨æ„äº‹é … 4ï¼šã€æ–°ã€‘å¦‚ä½•å»ºç«‹ã€Œè®€å– JSONã€çš„æŒ‡ä»¤ (é¤å»³æ¨è–¦ç¯„ä¾‹)

é€™å¯ä»¥è®“æ‚¨æ–°å¢ `#food [é—œéµå­—]` æˆ– `/food [é—œéµå­—]` æŒ‡ä»¤ã€‚

### æ­¥é©Ÿ 1ï¼šå»ºç«‹ `data/food_list.json`

åœ¨æ‚¨çš„ `data` è³‡æ–™å¤¾ä¸­å»ºç«‹ `food_list.json` (ä¸€é–‹å§‹å¯ä»¥åªæ˜¯ä¸€å€‹ç©ºæ¸…å–® `[]`)ï¼š

```json
[
    {
        "name": "é›²ç§‘å¾Œé–€é˜¿å§¨ç‚’é£¯",
        "creator_name": "UserA",
        "creator_id": 12345678901234567,
        "timestamp": "2025-11-01",
        "reviews": [
            {
                "user": "UserA",
                "rating": "5/5",
                "comment": "æ¨è–¦åŠ è¾£"
            },
            {
                "user": "UserB",
                "rating": "4/5",
                "comment": "è€é—†å¨˜äººå¾ˆå¥½"
            }
        ]
    }
]
```

### æ­¥é©Ÿ 2ï¼šå»ºç«‹ `cmds/food.py`

åœ¨ `cmds` è³‡æ–™å¤¾ä¸­å»ºç«‹æ–°æª”æ¡ˆ `food.py`ã€‚(æ­¤ç¯„ä¾‹åŒ…å« `add`, `list`, `search`, `remark`, `remove` åŠŸèƒ½)

```python
import discord
from discord.ext import commands
from core.classes import Cog_Extension
import json
import os
import logging
from discord import app_commands
from typing import List, Dict, Any, Optional
from datetime import datetime

FOOD_FILE = './data/food_list.json'

class Food(Cog_Extension):
    
    def __init__(self, bot):
        super().__init__(bot)
        self.food_list = self._load_food_list()

    # --- (è¼”åŠ©å‡½å¼ï¼š_load_food_list, _save_food_list, _find_food) ---
    def _load_food_list(self) -> List[Dict[str, Any]]:
        """è¼‰å…¥ food_list.jsonï¼Œå¦‚æœä¸å­˜åœ¨å‰‡å»ºç«‹ä¸€å€‹ç©ºæ¸…å–®"""
        try:
            if os.path.exists(FOOD_FILE):
                with open(FOOD_FILE, 'r', encoding='utf8') as f:
                    return json.load(f)
            else:
                with open(FOOD_FILE, 'w', encoding='utf8') as f:
                    json.dump([], f)
                return []
        except Exception as e:
            logging.error(f"è¼‰å…¥ {FOOD_FILE} å¤±æ•—: {e}")
            return []

    def _save_food_list(self):
        """å°‡ç›®å‰çš„ food_list å„²å­˜å› JSON æª”æ¡ˆ"""
        try:
            with open(FOOD_FILE, 'w', encoding='utf8') as f:
                json.dump(self.food_list, f, indent=4, ensure_ascii=False)
        except Exception as e:
            logging.error(f"å„²å­˜ {FOOD_FILE} å¤±æ•—: {e}")

    def _find_food(self, name: str) -> Optional[Dict[str, Any]]:
        """é€éåç¨±å°‹æ‰¾é¤å»³ (ä¸åˆ†å¤§å°å¯«)"""
        self.food_list = self._load_food_list() 
        for food in self.food_list:
            if food['name'].lower() == name.lower():
                return food
        return None

    # --- (è¼”åŠ©å‡½å¼ï¼š_create_food_embed - é€™æ˜¯ã€Œå¡ç‰‡å¼å›æ‡‰ã€çš„ç¯„ä¾‹) ---
    def _create_food_embed(self, food: Dict[str, Any]) -> discord.Embed:
        """å»ºç«‹é¤å»³è³‡è¨Šå¡ç‰‡ (å¡ç‰‡å¼å›æ‡‰)"""
        embed = discord.Embed(title=f"ğŸœ {food['name']}", color=discord.Color.blue())
        embed.add_field(name="æœ€åˆæ¨è–¦äºº", value=food['creator_name'], inline=True)
        embed.add_field(name="æ¨è–¦æ™‚é–“", value=food['timestamp'], inline=True)
        review_text = "å°šç„¡è©•åƒ¹"
        if food['reviews']:
            review_text = ""
            for review in food['reviews']:
                rating_str = ""
                if review.get('rating'):
                    rating_str = f"**{review.get('rating')}** "
                comment_str = review.get('comment', '...')
                user_str = review.get('user', 'åŒ¿å')
                review_text += f"â€¢ {rating_str}(by {user_str}): {comment_str}\n"
        embed.add_field(name="å¤§å®¶çš„å¿ƒå¾— & è©•åˆ†", value=review_text, inline=False)
        return embed

    # --- (éŒ¯èª¤è™•ç† on_command_error) ---
    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        if ctx.command and ctx.command.cog_name != 'Food':
            return
        logging.warning(f"Food Cog æ•ç²åˆ°æŒ‡ä»¤éŒ¯èª¤ (æŒ‡ä»¤: {ctx.command}, éŒ¯èª¤: {error})")
        is_private = ctx.interaction is not None
        if ctx.command and (ctx.command.name == 'food' or (ctx.command.root_parent and ctx.command.root_parent.name == 'food')):
            if isinstance(error, commands.MissingRequiredArgument):
                await ctx.send(f"âš ï¸ **åƒæ•¸éºæ¼éŒ¯èª¤ï¼š** æ‚¨å¿˜è¨˜æä¾› `{error.param.name}` åƒæ•¸äº†ï¼", ephemeral=is_private)
            else:
                pass # ä¸Šå ±

    # --- (æŒ‡ä»¤ç¾¤çµ„ food) ---
    @commands.hybrid_group(name='food', aliases=['eat', 'é¤å»³', 'åƒ'], description="é¤å»³æ¨è–¦æ¸…å–®")
    async def food(self, ctx: commands.Context):
        is_private = ctx.interaction is not None
        if ctx.invoked_subcommand is None:
            embed = discord.Embed(title="ğŸœ é¤å»³æ¨è–¦åŠŸèƒ½", description="é€™æ˜¯ä¸€ç³»åˆ—ç®¡ç†é¤å»³æ¸…å–®çš„æŒ‡ä»¤ã€‚", color=0x4682B4)
            embed.add_field(name=f"1. æ–°å¢é¤å»³", value=f"`{ctx.prefix}food add [åç¨±] [è©•åˆ†(é¸å¡«)] [å‚™è¨»(é¸å¡«)]`", inline=False)
            embed.add_field(name=f"2. æŸ¥çœ‹æ¸…å–®", value=f"`{ctx.prefix}food list`", inline=False)
            embed.add_field(name=f"3. æœå°‹é¤å»³", value=f"`{ctx.prefix}food search [åç¨±]`", inline=False)
            embed.add_field(name=f"4. å¢åŠ è©•åƒ¹", value=f"`{ctx.prefix}food review [åç¨±] [è©•åˆ†(é¸å¡«)] [å‚™è¨»]`", inline=False)
            embed.add_field(name=f"5. åˆªé™¤é¤å»³", value=f"`{ctx.prefix}food remove [åç¨±]`", inline=False)
            await ctx.send(embed=embed, ephemeral=is_private)

    # --- (å­æŒ‡ä»¤ add) ---
    @food.command(name='add', aliases=['æ–°å¢'], description="æ¨è–¦ä¸€å®¶æ–°é¤å»³")
    @app_commands.describe(name="é¤å»³åç¨±", rating="æ‚¨çš„è©•åˆ† (é¸å¡«, ä¾‹å¦‚: 5/5)", remark="æ‚¨çš„å‚™è¨»/å¿ƒå¾— (é¸å¡«)")
    async def add_food(self, ctx: commands.Context, name: str, rating: Optional[str] = None, *, remark: Optional[str] = None):
        is_private = ctx.interaction is not None
        if self._find_food(name):
            return await ctx.send(f"âŒ éŒ¯èª¤ï¼šã€Œ{name}ã€å·²ç¶“åœ¨æ¸…å–®ä¸­äº†ã€‚", ephemeral=is_private)
        reviews_list = []
        if rating or remark:
            reviews_list.append({"user": ctx.author.display_name, "rating": rating, "comment": remark})
        new_food = {
            "name": name,
            "creator_name": ctx.author.display_name,
            "creator_id": ctx.author.id,
            "timestamp": datetime.now().strftime("%Y-%m-%d"),
            "reviews": reviews_list
        }
        self.food_list.append(new_food)
        self._save_food_list()
        await ctx.send(f"âœ… æˆåŠŸæ–°å¢ã€Œ{name}ã€ï¼", embed=self._create_food_embed(new_food), ephemeral=is_private)

    # --- (å­æŒ‡ä»¤ list) ---
    @food.command(name='list', aliases=['æ¸…å–®'], description="åˆ—å‡ºæ‰€æœ‰å·²æ¨è–¦çš„é¤å»³")
    async def list_food(self, ctx: commands.Context):
        is_private = ctx.interaction is not None
        self.food_list = self._load_food_list() 
        if not self.food_list:
            return await ctx.send("ç›®å‰æ¸…å–®æ˜¯ç©ºçš„ï¼Œå¿«ä½¿ç”¨ `/food add` æ–°å¢ç¬¬ä¸€å®¶å§ï¼", ephemeral=is_private)
        embed = discord.Embed(title="ğŸœ é¤å»³æ¨è–¦ç¸½è¦½", color=0x4682B4)
        all_names = [f"â€¢ **{food['name']}** (by {food['creator_name']})" for food in self.food_list]
        embed.description = "\n".join(all_names)
        embed.set_footer(text=f"ä½¿ç”¨ `{ctx.prefix}food search [åç¨±]` ä¾†æŸ¥çœ‹è©³ç´°è³‡è¨Š")
        await ctx.send(embed=embed, ephemeral=is_private)

    # --- (å­æŒ‡ä»¤ search) ---
    @food.command(name='search', aliases=['find', 'æŸ¥'], description="æŸ¥è©¢ç‰¹å®šé¤å»³çš„è©³ç´°è³‡è¨Š")
    @app_commands.describe(name="è¦æŸ¥è©¢çš„é¤å»³åç¨±")
    async def search_food(self, ctx: commands.Context, name: str):
        is_private = ctx.interaction is not None
        food_entry = self._find_food(name)
        if food_entry:
            await ctx.send(embed=self._create_food_embed(food_entry), ephemeral=is_private)
        else:
            await ctx.send(f"âŒ æ‰¾ä¸åˆ°åç¨±ç‚ºã€Œ{name}ã€çš„é¤å»³ã€‚", ephemeral=is_private)

    # --- (å­æŒ‡ä»¤ review) ---
    @food.command(name='review', aliases=['è©•åƒ¹', 'addnote'], description="ç‚ºå·²å­˜åœ¨çš„é¤å»³æ–°å¢è©•åƒ¹")
    @app_commands.describe(name="é¤å»³åç¨±", rating="æ‚¨çš„è©•åˆ† (é¸å¡«, ä¾‹å¦‚: 3/5)", comment="è¦æ–°å¢çš„å‚™è¨»/å¿ƒå¾— (é¸å¡«)")
    async def add_review(self, ctx: commands.Context, name: str, rating: Optional[str] = None, *, comment: Optional[str] = None):
        is_private = ctx.interaction is not None
        if not rating and not comment:
             return await ctx.send(f"âŒ æ‚¨å¿…é ˆè‡³å°‘æä¾›ã€Œè©•åˆ†ã€æˆ–ã€Œå‚™è¨»ã€å…¶ä¸­ä¸€é …ã€‚", ephemeral=is_private)
        food_entry = self._find_food(name)
        if not food_entry:
            return await ctx.send(f"âŒ æ‰¾ä¸åˆ°åç¨±ç‚ºã€Œ{name}ã€çš„é¤å»³ï¼Œç„¡æ³•æ–°å¢è©•åƒ¹ã€‚", ephemeral=is_private)
        new_review = {"user": ctx.author.display_name, "rating": rating, "comment": comment}
        food_entry['reviews'].append(new_review)
        self._save_food_list()
        await ctx.send(f"âœ… å·²ç‚ºã€Œ{food_entry['name']}ã€æ–°å¢è©•åƒ¹ï¼", embed=self._create_food_embed(food_entry), ephemeral=is_private)

    # --- (å­æŒ‡ä»¤ remove) ---
    @food.command(name='remove', aliases=['delete', 'åˆªé™¤'], description="åˆªé™¤ä¸€å®¶é¤å»³æ¨è–¦")
    @app_commands.describe(name="è¦åˆªé™¤çš„é¤å»³åç¨±")
    async def remove_food(self, ctx: commands.Context, name: str):
        is_private = ctx.interaction is not None
        food_entry = self._find_food(name)
        if not food_entry:
            return await ctx.send(f"âŒ æ‰¾ä¸åˆ°åç¨±ç‚ºã€Œ{name}ã€çš„é¤å»³ã€‚", ephemeral=is_private)
        self.food_list.remove(food_entry)
        self._save_food_list()
        await ctx.send(f"ğŸ—‘ï¸ å·²åˆªé™¤ã€Œ{name}ã€ã€‚ (æ“ä½œè€…: {ctx.author.display_name})", ephemeral=is_private)

async def setup(bot):
    await bot.add_cog(Food(bot))
```

-----

## âš ï¸ æ³¨æ„äº‹é … 5ï¼šã€æ–°ã€‘å¦‚ä½•å»ºç«‹ã€Œé—œéµå­—è‡ªå‹•å›æ‡‰ã€(ç„¡é ˆ \#)

é€™å¯ä»¥è®“æ©Ÿå™¨äººåœ¨åµæ¸¬åˆ°ç‰¹å®šè¨Šæ¯ï¼ˆå¦‚ "ä½ å¥½"ï¼‰æ™‚è‡ªå‹•å›è¦†ã€‚

### æ­¥é©Ÿ 1ï¼šç¢ºèª `bot.py` çš„ `Intents`

æ‚¨çš„ `bot.py` å¿…é ˆå•Ÿç”¨ `message_content`ã€‚
**æ‚¨ç›®å‰çš„ `intents = discord.Intents.all()` å·²ç¶“åŒ…å«äº†é€™é …æ¬Šé™ï¼Œæ‰€ä»¥æ‚¨ä¸éœ€è¦ä¿®æ”¹ `bot.py`ã€‚**

### æ­¥é©Ÿ 2ï¼šå»ºç«‹ `cmds/listener.py`

åœ¨ `cmds` è³‡æ–™å¤¾ä¸­å»ºç«‹æ–°æª”æ¡ˆ `listener.py`ã€‚

```python
import discord
from discord.ext import commands
from core.classes import Cog_Extension
import logging
import random # (ç¯„ä¾‹ 3 éœ€è¦)

class Listener(Cog_Extension):

    @commands.Cog.listener()
    async def on_message(self, msg: discord.Message):
        
        # 1. æª¢æŸ¥æ˜¯å¦ç‚ºæ©Ÿå™¨äººæœ¬èº«ï¼Œé˜²æ­¢ç„¡é™å¾ªç’°
        if msg.author == self.bot.user:
            return
            
        # 2. æª¢æŸ¥æ˜¯å¦åœ¨ DM (ç§äººè¨Šæ¯) ä¸­ (å¯é¸)
        if isinstance(msg.channel, discord.DMChannel):
            return

        # 3. æª¢æŸ¥è¨Šæ¯å…§å®¹
        content = msg.content.lower() # è½‰æ›ç‚ºå°å¯«

        # --- ç¯„ä¾‹ 1ï¼šå®Œå…¨ç¬¦åˆ (å›è¦†æ–‡å­—) ---
        if content == "ä½ å¥½":
            await msg.channel.send("ä½ å¥½å•Šï¼")
            return # (å›è¦†å¾Œå°±å¯ä»¥é€€å‡ºäº†)

        # --- ç¯„ä¾‹ 2ï¼šåŒ…å«é—œéµå­— (å›è¦†ã€Œæ¨™æº–ã€è¡¨æƒ…ç¬¦è™Ÿ) ---
        if "æ—©å®‰" in content:
            try:
                await msg.add_reaction("â˜€ï¸") # åŠ ä¸Šå¤ªé™½è¡¨æƒ…ç¬¦è™Ÿ
            except discord.Forbidden:
                logging.warning(f"ç„¡æ³•åœ¨é »é“ {msg.channel.name} æ–°å¢è¡¨æƒ…ç¬¦è™Ÿ (æ¬Šé™ä¸è¶³)")
            return

        # --- ç¯„ä¾‹ 3ï¼šåŒ…å«é—œéµå­— (éš¨æ©Ÿå›è¦†æ–‡å­—) ---
        if "å¥½æ£’" in content or "å¤ªå¼·äº†" in content:
            responses = ["è¬è¬èª‡çï¼", "é‚„å¥½å•¦ (Â´âˆ€`)", "ä½èª¿ä½èª¿ï½"]
            await msg.channel.send(random.choice(responses))
            return

        # --- ç¯„ä¾‹ 4ï¼šå®Œå…¨ç¬¦åˆ (å›è¦†åœ–ç‰‡ URL) ---
        if content == "è²¼åœ–":
            image_url = "https://i.imgur.com/86n43L8.gif" # ç¯„ä¾‹è²¼åœ–
            await msg.channel.send(image_url)
            return
            
        # --- ç¯„ä¾‹ 5ï¼šå›è¦†ã€Œæœ¬æ©Ÿåœ–ç‰‡ã€---
        # Docker å¦‚ä½•æ‰“åŒ…ï¼š
        # 1. æ‚¨çš„ Dockerfile ä¸­æœ‰ `COPY . .` æŒ‡ä»¤ã€‚
        # 2. é€™æœƒå°‡æ‚¨ GitHub å„²å­˜åº«ä¸­çš„ã€Œæ‰€æœ‰æª”æ¡ˆã€éƒ½è¤‡è£½åˆ° Docker æ˜ åƒæª”çš„ `/app/` ç›®éŒ„ä¸­ã€‚
        # åœ–ç‰‡è¦æ”¾å“ªè£¡ï¼š
        # 1. åœ¨æ‚¨çš„å°ˆæ¡ˆæ ¹ç›®éŒ„ï¼ˆèˆ‡ bot.py åŒå±¤ï¼‰å»ºç«‹ä¸€å€‹è³‡æ–™å¤¾ï¼Œä¾‹å¦‚ `data/`ã€‚
        # 2. å°‡æ‚¨çš„åœ–ç‰‡ (ä¾‹å¦‚ `my_image.png`) æ”¾å…¥è©²è³‡æ–™å¤¾ã€‚
        #
        if content == "æœ¬æ©Ÿåœ–ç‰‡":
            try:
                # Docker å®¹å™¨å…§çš„è·¯å¾‘æœƒæ˜¯ /app/data/my_image.png
                await msg.channel.send(file=discord.File('./data/my_image.png'))
            except FileNotFoundError:
                await msg.channel.send("âŒ æŠ±æ­‰ï¼Œæ‰¾ä¸åˆ°æœ¬æ©Ÿåœ–ç‰‡æª”æ¡ˆã€‚")
                logging.error("åœ¨ on_message ä¸­æ‰¾ä¸åˆ° './data/my_image.png' æª”æ¡ˆã€‚")
            return

        # --- ç¯„ä¾‹ 6ï¼šå›è¦†ã€Œè‡ªè¨‚è¡¨æƒ…ç¬¦è™Ÿã€---
        # å¦‚ä½•å–å¾— IDï¼š
        # 1. åœ¨ Discord é »é“ä¸­è¼¸å…¥ \:æ‚¨è¦çš„è¡¨æƒ…ç¬¦è™Ÿ: (ä¾‹å¦‚ \:my_emoji:)
        # 2. Discord æœƒå›å‚³ <a:my_emoji:123456789012345678> (å‹•åœ–)
        #    æˆ– <:my_emoji:123456789012345678> (éœæ…‹)
        # 3. æŠŠã€Œå®Œæ•´çš„å­—ä¸²ã€è¤‡è£½ä¸‹ä¾†
        #
        if "æƒ³ç¡è¦º" in content:
            # --- æ–¹æ³• Aï¼šä½œç‚ºã€Œè¨Šæ¯ã€å›è¦† ---
            emoji_string = "<:my_sleep_emoji:123456789>" 
            await msg.channel.send(emoji_string)
            return

        if "æ‹æ‰‹" in content:
            # --- æ–¹æ³• Bï¼šä½œç‚ºã€Œåæ‡‰ã€æ–°å¢ ---
            reaction_emoji_string = "<:my_clap_emoji:987654321>"
            try:
                await msg.add_reaction(reaction_emoji_string)
            except (discord.Forbidden, discord.HTTPException):
                logging.warning(f"ç„¡æ³•æ–°å¢è‡ªè¨‚è¡¨æƒ…ç¬¦è™Ÿ {reaction_emoji_string} (æ¬Šé™ä¸è¶³æˆ–æ‰¾ä¸åˆ°)")
            return

        # 4. âŒ çµ•å°ç¦æ­¢ âŒ
        # ä¸è¦åœ¨ Cog çš„ on_message ä¸­ä½¿ç”¨ process_commands
        # (éŒ¯èª¤çš„å¯«æ³• - å¿…é ˆåˆªé™¤):
        # await self.bot.process_commands(msg)

async def setup(bot):
    await bot.add_cog(Listener(bot))
```

-----

## âš ï¸ æ³¨æ„äº‹é … 6ï¼šã€æ–°ã€‘å¦‚ä½•å›è¦†ã€Œæ–¹æ¡†ã€ (Embeds)

æ‚¨åœ¨ `food.py` å’Œ `enrollment_monitor.py` ä¸­å·²ç¶“å¤§é‡ä½¿ç”¨å®ƒã€‚Embeds æ˜¯è®“æ©Ÿå™¨äººå›è¦†æ›´ç¾è§€çš„é—œéµã€‚

### âœ… ç¯„ä¾‹ï¼šå»ºç«‹ä¸€å€‹åŒ…å«ã€Œæ¨™é¡Œã€æè¿°ã€ä¸¦æ’æ¬„ä½ã€éä¸¦æ’æ¬„ä½ã€çš„ Embed

```python
    @commands.hybrid_command(name="info", description="é¡¯ç¤ºè³‡è¨Šå¡ç‰‡")
    async def info(self, ctx: commands.Context):
        is_private = ctx.interaction is not None

        # 1. å»ºç«‹ Embed ç‰©ä»¶
        embed = discord.Embed(
            title="é€™æ˜¯ä¸€å€‹æ¨™é¡Œ",
            description="é€™æ˜¯æè¿°æ–‡å­—ï¼Œæ‚¨å¯ä»¥åœ¨é€™è£¡å¯«æ¯”è¼ƒé•·çš„èªªæ˜ã€‚",
            color=discord.Color.blue() # é¡¯ç¤ºåœ¨å·¦å´çš„é¡è‰²
        )
        
        # 2. (å¯é¸) è¨­å®šä½œè€…
        embed.set_author(name=f"ç”± {ctx.author.display_name} è«‹æ±‚", icon_url=ctx.author.avatar.url)
        
        # 3. (å¯é¸) è¨­å®šåœ–ç‰‡
        embed.set_thumbnail(url="https.i.imgur.com/your_image.png")

        # 4. æ–°å¢ã€Œæ¬„ä½ (Fields)ã€
        
        # --- ä¸¦æ’æ¬„ä½ (inline=True) ---
        # (é€™å…©å€‹æ¬„ä½æœƒä¸¦æ’é¡¯ç¤º)
        embed.add_field(name="æ¬„ä½ 1 (ä¸¦æ’)", value="é€™æ˜¯æ¬„ä½ 1 çš„å…§å®¹", inline=True)
        embed.add_field(name="æ¬„ä½ 2 (ä¸¦æ’)", value="é€™æ˜¯æ¬„ä½ 2 çš„å…§å®¹", inline=True)
        
        # --- ç¨ç«‹æ¬„ä½ (inline=False) ---
        # (é€™å€‹æ¬„ä½æœƒä½”æ“šä¸€æ•´è¡Œ)
        embed.add_field(name="æ¬„ä½ 3 (ç¨ç«‹)", value="é€™æ˜¯æ¬„ä½ 3 çš„å…§å®¹ï¼Œé€šå¸¸ç”¨æ–¼è¼ƒé•·çš„æ–‡å­—ã€‚", inline=False)

        # 5. (å¯é¸) è¨­å®šè¨»è…³
        embed.set_footer(text=f"NBot | {datetime.now().strftime('%Y-%m-%d')}")

        # 6. ç™¼é€ Embed
        await ctx.send(embed=embed, ephemeral=is_private)
```

-----

## âš ï¸ æ³¨æ„äº‹é … 7ï¼šã€æ–°ã€‘å¦‚ä½•å»ºç«‹ã€ŒReaction Roleã€ (è¡¨æƒ…ç¬¦è™Ÿèº«ä»½çµ„)

é€™æ˜¯ `enrollment_monitor.py` çš„æ ¸å¿ƒåŠŸèƒ½ã€‚å®ƒä½¿ç”¨ã€ŒRawã€äº‹ä»¶ï¼Œé€™æ¨£å³ä½¿æ©Ÿå™¨äººé‡æ–°å•Ÿå‹•ï¼Œä¹Ÿèƒ½ç›£è½**èˆŠè¨Šæ¯**çš„è¡¨æƒ…ç¬¦è™Ÿã€‚

### æ­¥é©Ÿ 1ï¼šå®šç¾©ã€Œè¦ç›£è½çš„è¨Šæ¯ IDã€å’Œã€Œèº«ä»½çµ„ IDã€

æ‚¨å¿…é ˆå…ˆçŸ¥é“æ‚¨è¦ç›£è½å“ªä¸€å‰‡è¨Šæ¯ï¼Œä»¥åŠè¦çµ¦äºˆå“ªå€‹èº«ä»½çµ„ã€‚
ï¼ˆåœ¨ `enrollment_monitor` ä¸­ï¼Œæˆ‘å€‘æ˜¯ã€Œå‹•æ…‹ã€å„²å­˜é€™äº› IDï¼Œä½†åœ¨é€™è£¡æˆ‘å€‘ç”¨ã€Œå›ºå®šã€ID ä½œç‚ºç¯„ä¾‹ï¼‰

### æ­¥é©Ÿ 2ï¼šå»ºç«‹ `cmds/reaction_role.py`

```python
import discord
from discord.ext import commands
from core.classes import Cog_Extension
import logging

# --- âœ… è¨­å®š ---
# 1. å¡«å…¥æ‚¨è¦ç›£è½çš„ã€Œè¨Šæ¯ IDã€ (å¿…é ˆæ˜¯æ•¸å­—)
REACTION_MESSAGE_ID = 1234567890123456789 

# 2. å»ºç«‹ä¸€å€‹ã€Œè¡¨æƒ…ç¬¦è™Ÿã€å’Œã€Œèº«ä»½çµ„ IDã€çš„å°æ‡‰å­—å…¸
# (è¡¨æƒ…ç¬¦è™Ÿå¿…é ˆæ˜¯ Unicodeï¼Œè‡ªè¨‚è¡¨æƒ…ç¬¦è™Ÿè¼ƒè¤‡é›œ)
ROLE_MAP = {
    "ğŸ””": 987654321098765432,  # ç¯„ä¾‹ï¼š "ğŸ””" å°æ‡‰åˆ° ID ç‚º 9876... çš„èº«ä»½çµ„
    "âœ…": 876543210987654321   # ç¯„ä¾‹ï¼š "âœ…" å°æ‡‰åˆ° ID ç‚º 8765... çš„èº«ä»½çµ„
}
# ---

class ReactionRole(Cog_Extension):

    # --- è¼”åŠ©å‡½å¼ï¼šæª¢æŸ¥ä¸¦ç²å–è³‡æ–™ ---
    async def _get_reaction_data(self, payload: discord.RawReactionActionEvent):
        # 1. æª¢æŸ¥æ˜¯å¦ç‚ºæˆ‘å€‘è¦ç›£è½çš„è¨Šæ¯
        if payload.message_id != REACTION_MESSAGE_ID:
            return None, None, None
            
        # 2. æª¢æŸ¥è¡¨æƒ…ç¬¦è™Ÿæ˜¯å¦åœ¨æˆ‘å€‘çš„åœ°åœ–ä¸­
        emoji_str = str(payload.emoji)
        role_id = ROLE_MAP.get(emoji_str)
        if not role_id:
            return None, None, None # ä¸æ˜¯æˆ‘å€‘è¦çš„è¡¨æƒ…ç¬¦è™Ÿ
            
        # 3. ç²å– Guild, Role, Member
        guild = self.bot.get_guild(payload.guild_id)
        if not guild: return None, None, None
            
        role = guild.get_role(role_id)
        if not role:
            logging.warning(f"Reaction Role: æ‰¾ä¸åˆ°èº«ä»½çµ„ ID {role_id}")
            return None, None, None
        
        # 4. ç²å–æˆå“¡ (add å’Œ remove çš„ payload ä¸åŒ)
        member = None
        if payload.event_type == 'REACTION_ADD':
            member = payload.member # add äº‹ä»¶æœƒç›´æ¥æä¾› member
        elif payload.event_type == 'REACTION_REMOVE':
            try:
                member = await guild.fetch_member(payload.user_id) # remove äº‹ä»¶éœ€è¦æ‰‹å‹•æŠ“å–
            except discord.NotFound:
                logging.warning(f"Reaction Role: ä½¿ç”¨è€… {payload.user_id} ç§»é™¤åæ‡‰ï¼Œä½†æ‰¾ä¸åˆ°è©²æˆå“¡")
        
        return member, role, guild

    # =========================================================
    # âœ… ç›£è½ã€Œæ–°å¢ã€è¡¨æƒ…ç¬¦è™Ÿ (on_raw_reaction_add)
    # =========================================================
    @commands.Cog.listener()
    async def on_raw_reaction_add(self, payload: discord.RawReactionActionEvent):
        
        # 1. å¿½ç•¥æ©Ÿå™¨äºº
        if payload.user_id == self.bot.user.id:
            return

        # 2. æª¢æŸ¥ä¸¦ç²å–è³‡æ–™
        member, role, guild = await self._get_reaction_data(payload)
        if not member or not role:
            return # è³‡æ–™ä¸å®Œæ•´

        # 3. æ–°å¢èº«ä»½çµ„
        try:
            if role not in member.roles:
                await member.add_roles(role, reason="Reaction Role")
                logging.info(f"[Reaction Role] å·²å°‡ {role.name} åŠ å…¥ {member.display_name}")
        except discord.Forbidden:
            logging.error(f"[Reaction Role] æ¬Šé™ä¸è¶³ï¼Œç„¡æ³•å°‡ {role.name} åŠ å…¥ {member.display_name}")
        except Exception as e:
            logging.error(f"[Reaction Role] æ–°å¢èº«ä»½çµ„æ™‚å¤±æ•—: {e}")

    # =========================================================
    # âœ… ç›£è½ã€Œç§»é™¤ã€è¡¨æƒ…ç¬¦è™Ÿ (on_raw_reaction_remove)
    # =========================================================
    @commands.Cog.listener()
    async def on_raw_reaction_remove(self, payload: discord.RawReactionActionEvent):

        # 1. å¿½ç•¥æ©Ÿå™¨äºº
        if payload.user_id == self.bot.user.id:
            return
            
        # 2. æª¢æŸ¥ä¸¦ç²å–è³‡æ–™
        member, role, guild = await self._get_reaction_data(payload)
        if not member or not role:
            return # è³‡æ–™ä¸å®Œæ•´

        # 3. ç§»é™¤èº«ä»½çµ„
        try:
            if role in member.roles:
                await member.remove_roles(role, reason="Reaction Role Remove")
                logging.info(f"[Reaction Role] å·²å¾ {member.display_name} ç§»é™¤ {role.name}")
        except discord.Forbidden:
            logging.error(f"[Reaction Role] æ¬Šé™ä¸è¶³ï¼Œç„¡æ³•å¾ {member.display_name} ç§»é™¤ {role.name}")
        except Exception as e:
            logging.error(f"[Reaction Role] ç§»é™¤èº«ä»½çµ„æ™‚å¤±æ•—: {e}")

async def setup(bot):
    await bot.add_cog(ReactionRole(bot))
```

### é€™æ˜¯ä¸€äº›ç¯„ä¾‹ä»¥åŠæœªä¾†æ–¹å‘
(æœ‰ç©ºå¯ä»¥æ”¹)

å¥½çš„ï¼Œå¦‚æœæ‚¨å¸Œæœ›è®“æ‰€æœ‰äººï¼ˆè€Œä¸åªæ˜¯æ©Ÿå™¨äººæ“æœ‰è€…ï¼‰éƒ½èƒ½ä½¿ç”¨ `load`, `reload`, `unload` æŒ‡ä»¤ï¼Œæ‚¨å¯ä»¥é€™æ¨£ä¿®æ”¹ï¼š

æ‚¨åªéœ€è¦åœ¨ `bot.py` æª”æ¡ˆä¸­ï¼Œæ‰¾åˆ°é€™ä¸‰å€‹æŒ‡ä»¤çš„å®šç¾©ï¼Œä¸¦**åˆªé™¤æˆ–è¨»è§£æ‰ `@commands.is_owner()` é€™ä¸€è¡Œ**ã€‚

åŒæ™‚ï¼Œæ‚¨ä¹Ÿæ‡‰è©²ä¿®æ”¹ `description` ç§»é™¤ã€Œ[åƒ…é™æ“æœ‰è€…]ã€çš„æ–‡å­—ã€‚

### ä¿®æ”¹ç¯„ä¾‹ (ä»¥ `load` æŒ‡ä»¤ç‚ºä¾‹)ï¼š

**ä¿®æ”¹å‰ (åƒ…é™æ“æœ‰è€…)ï¼š**

```python
@bot.hybrid_command(name="load", description="[åƒ…é™æ“æœ‰è€…] è¼‰å…¥ä¸€å€‹ Cog æ¨¡çµ„")
@app_commands.describe(extension="è¦è¼‰å…¥çš„æ¨¡çµ„åç¨± (ä¾‹å¦‚: music_play)")
@commands.is_owner() # <--- é€™ä¸€è¡Œé™åˆ¶äº†æ¬Šé™
async def load(ctx: commands.Context, extension: str):
    is_private = ctx.interaction is not None
    try:
        await bot.load_extension(f'cmds.{extension}')
        await ctx.send(f"âœ… æ¨¡çµ„ `cmds.{extension}` è¼‰å…¥æˆåŠŸã€‚", ephemeral=is_private)
    except Exception as e:
        await ctx.send(f"âŒ è¼‰å…¥ `cmds.{extension}` å¤±æ•—: {e}", ephemeral=is_private)
```

**ä¿®æ”¹å¾Œ (æ‰€æœ‰äººå¯ç”¨)ï¼š**

```python
@bot.hybrid_command(name="load", description="è¼‰å…¥ä¸€å€‹ Cog æ¨¡çµ„") # <--- ç§»é™¤ "[åƒ…é™æ“æœ‰è€…]"
@app_commands.describe(extension="è¦è¼‰å…¥çš„æ¨¡çµ„åç¨± (ä¾‹å¦‚: music_play)")
# @commands.is_owner() # <--- åˆªé™¤æˆ–è¨»è§£æ‰é€™ä¸€è¡Œ
async def load(ctx: commands.Context, extension: str):
    is_private = ctx.interaction is not None
    try:
        await bot.load_extension(f'cmds.{extension}')
        await ctx.send(f"âœ… æ¨¡çµ„ `cmds.{extension}` è¼‰å…¥æˆåŠŸã€‚", ephemeral=is_private)
    except Exception as e:
        await ctx.send(f"âŒ è¼‰å…¥ `cmds.{extension}` å¤±æ•—: {e}", ephemeral=is_private)
```

(æ‚¨éœ€è¦å° `unload` å’Œ `reload` ä¹Ÿé€²è¡ŒåŒæ¨£çš„ä¿®æ”¹ã€‚)

-----

### âš ï¸ åš´é‡å®‰å…¨è­¦å‘Šï¼

æˆ‘**å¼·çƒˆä¸å»ºè­°**æ‚¨å°‡é€™äº›æŒ‡ä»¤é–‹æ”¾çµ¦ã€Œæ‰€æœ‰äººã€ã€‚

é€™æ„å‘³è‘—**ä»»ä½•**ä¼ºæœå™¨ä¸Šçš„**ä»»ä½•**ä½¿ç”¨è€…éƒ½å¯ä»¥éš¨æ™‚ï¼š

1.  **é—œé–‰æ‚¨çš„åŠŸèƒ½**ï¼š(ä¾‹å¦‚ï¼š`#unload music_play` æˆ– `#unload enrollment_monitor`)
2.  **ç™±ç˜“æ©Ÿå™¨äºº**ï¼š(ä¾‹å¦‚ï¼šé€£çºŒ `reload` æˆ– `load` ä¸å­˜åœ¨çš„æ¨¡çµ„)

### 

### æ›´å®‰å…¨çš„æ›¿ä»£æ–¹æ¡ˆ (æ¨è–¦)

å¦‚æœæ‚¨åªæ˜¯æƒ³è®“ã€Œä¼ºæœå™¨ç®¡ç†å“¡ã€ä¹Ÿèƒ½ä½¿ç”¨ (è€Œä¸åªæ˜¯æ‚¨è‡ªå·±)ï¼Œæ‚¨æ‡‰è©²å°‡ `@commands.is_owner()` æ›¿æ›ç‚ºï¼š
`@commands.has_permissions(manage_guild=True)` (ä»£è¡¨ã€Œæ“æœ‰ç®¡ç†ä¼ºæœå™¨æ¬Šé™ã€çš„äºº)

**æ¨è–¦çš„ä¿®æ”¹æ–¹å¼ï¼š**

```python
@bot.hybrid_command(name="load", description="[åƒ…é™ç®¡ç†å“¡] è¼‰å…¥ä¸€å€‹ Cog æ¨¡çµ„") # <--- ä¿®æ”¹æè¿°
@app_commands.describe(extension="è¦è¼‰å…¥çš„æ¨¡çµ„åç¨± (ä¾‹å¦‚: music_play)")
@commands.has_permissions(manage_guild=True) # <--- æ›¿æ› @commands.is_owner()
async def load(ctx: commands.Context, extension: str):
    # ... (ç¨‹å¼ç¢¼ä¸è®Š) ...
```


1.  `load`, `reload`, `unload` æŒ‡ä»¤**ä¿ç•™åœ¨ `bot.py` ä¸­**ï¼Œä½†å°‡å®ƒå€‘ä¹Ÿå‡ç´šç‚º `hybrid_command`ï¼ˆåŒæ™‚æ”¯æ´ `#` å’Œ `/`ï¼‰ã€‚
2.  æ‚¨ä¹‹å‰åœ¨ `utils.py` ä¸­çš„ `image` (ç¶²è·¯åœ–ç‰‡), `say` (å­¸æˆ‘), `ids` (ID æŸ¥è©¢) ä¸‰å€‹æŒ‡ä»¤ï¼Œè¦**å…¨éƒ¨åˆ†é–‹**ï¼Œè®Šæˆä¸‰å€‹ç¨ç«‹çš„æª”æ¡ˆã€‚

é€™æ²’æœ‰å•é¡Œã€‚è«‹**åˆªé™¤**æ‚¨èˆŠçš„ `cmds/utils.py` æª”æ¡ˆ (å¦‚æœæœ‰çš„è©±)ï¼Œç„¶å¾Œç”¨ä¸‹é¢ 4 å€‹æª”æ¡ˆæ›¿æ›/å»ºç«‹ã€‚

(è«‹æ³¨æ„ï¼š`load`, `reload`, `unload` ä»æœƒé™åˆ¶**åƒ…é™æ©Ÿå™¨äººæ“æœ‰è€…**ä½¿ç”¨ã€‚)

-----

### æª”æ¡ˆ 1ï¼š `bot.py` (å®Œæ•´ç‰ˆ)

(æˆ‘å·²å°‡ `load`, `reload`, `unload` å¾ `@bot.command()` ä¿®æ”¹ç‚º `@bot.hybrid_command()`)

```python
import discord
from discord.ext import commands, tasks
import json
import asyncio
import os
import requests
from dotenv import load_dotenv # å¼•å…¥ load_dotenv
import logging # å¼•å…¥ logging æ¨¡çµ„
from discord import app_commands # âœ… å¼•å…¥ app_commands

# --- è®€å– .env æª”æ¡ˆ ---
load_dotenv()

# --- æ ¸å¿ƒè¨­å®š (å¾ç’°å¢ƒè®Šæ•¸è®€å–) ---
intents = discord.Intents.all()
bot = commands.Bot(command_prefix='#' , intents = intents)

# å¾ç’°å¢ƒè®Šæ•¸ç²å–é…ç½®
DISCORD_TOKEN = os.getenv('DISCORD_TOKEN')
CHANNEL_ID = os.getenv('CHANNEL_ID')
UPTIME_KUMA_URL = os.getenv('UPTIME_KUMA_URL')

# è¨­å®šå¿ƒè·³é–“éš” (ç§’)ã€‚
HEARTBEAT_INTERVAL_SECONDS = 240 # æ¯ 4 åˆ†é˜ (240 ç§’)

# =========================================================
# âœ… äº”ã€æ“´å±•æ¨¡çµ„ç®¡ç†æŒ‡ä»¤ (å·²å‡ç´šç‚º Hybrid)
# =========================================================

@bot.hybrid_command(name="load", description="[åƒ…é™æ“æœ‰è€…] è¼‰å…¥ä¸€å€‹ Cog æ¨¡çµ„")
@app_commands.describe(extension="è¦è¼‰å…¥çš„æ¨¡çµ„åç¨± (ä¾‹å¦‚: music_play)")
@commands.is_owner() # åƒ…é™æ©Ÿå™¨äººæ“æœ‰è€…
async def load(ctx: commands.Context, extension: str):
    is_private = ctx.interaction is not None
    try:
        await bot.load_extension(f'cmds.{extension}')
        await ctx.send(f"âœ… æ¨¡çµ„ `cmds.{extension}` è¼‰å…¥æˆåŠŸã€‚", ephemeral=is_private)
    except Exception as e:
        await ctx.send(f"âŒ è¼‰å…¥ `cmds.{extension}` å¤±æ•—: {e}", ephemeral=is_private)

@bot.hybrid_command(name="unload", description="[åƒ…é™æ“æœ‰è€…] å¸è¼‰ä¸€å€‹ Cog æ¨¡çµ„")
@app_commands.describe(extension="è¦å¸è¼‰çš„æ¨¡çµ„åç¨± (ä¾‹å¦‚: music_play)")
@commands.is_owner()
async def unload(ctx: commands.Context, extension: str):
    is_private = ctx.interaction is not None
    try:
        await bot.unload_extension(f'cmds.{extension}')
        await ctx.send(f"âœ… æ¨¡çµ„ `cmds.{extension}` å¸è¼‰æˆåŠŸã€‚", ephemeral=is_private)
    except Exception as e:
        await ctx.send(f"âŒ å¸è¼‰ `cmds.{extension}` å¤±æ•—: {e}", ephemeral=is_private)

@bot.hybrid_command(name="reload", description="[åƒ…é™æ“æœ‰è€…] é‡æ–°è¼‰å…¥ä¸€å€‹ Cog æ¨¡çµ„")
@app_commands.describe(extension="è¦é‡æ–°è¼‰å…¥çš„æ¨¡çµ„åç¨± (ä¾‹å¦‚: music_play)")
@commands.is_owner()
async def reload(ctx: commands.Context, extension: str):
    is_private = ctx.interaction is not None
    try:
        await bot.reload_extension(f'cmds.{extension}')
        await ctx.send(f"âœ… æ¨¡çµ„ `cmds.{extension}` é‡æ–°è¼‰å…¥æˆåŠŸã€‚", ephemeral=is_private)
    except Exception as e:
        await ctx.send(f"âŒ é‡æ–°è¼‰å…¥ `cmds.{extension}` å¤±æ•—: {e}", ephemeral=is_private)


# --- Uptime Kuma å¿ƒè·³ä»»å‹™ ---
@tasks.loop(seconds=HEARTBEAT_INTERVAL_SECONDS)
async def send_heartbeat():
    """å®šæœŸå‘ Uptime Kuma ç™¼é€ HTTP è«‹æ±‚ä»¥ä¿æŒç›£æ§å™¨ç‚º 'Up' ç‹€æ…‹ï¼Œä¸¦å‚³é€å»¶é²æ•¸å€¼"""
    if UPTIME_KUMA_URL:
        try:
            latency_ms = round(bot.latency * 1000)
            heartbeat_url_with_ping = f"{UPTIME_KUMA_URL}{latency_ms}"
            await asyncio.to_thread(requests.get, heartbeat_url_with_ping, timeout=10) 
            logging.info(f"Heartbeat sent successfully (Ping: {latency_ms}ms).") 
        except Exception as e:
            logging.warning(f"Failed to send heartbeat to Uptime Kuma: {e}")

# --- å•Ÿå‹•æ“´å±•æ¨¡çµ„ (ä¿æŒä¸è®Š) ---
async def load_extensions(bot):
    cmds_dir = './cmds'
    if os.path.exists(cmds_dir):
        for filename in os.listdir(cmds_dir):
            if filename.endswith(".py"):
                try:
                    await bot.load_extension(f'cmds.{filename[:-3]}')
                    logging.info(f'Loaded extension: {filename[:-3]}')
                except Exception as e:
                    logging.error(f'Failed to load extension {filename[:-3]}: {e}')
    else:
        logging.error("The 'cmds' directory does not exist.")


@bot.event # è®“æ©Ÿå™¨äººä¸Šç·šä¸¦æç¤º
async def on_ready():
    """æ©Ÿå™¨äººæº–å‚™å°±ç·’æ™‚åŸ·è¡Œçš„äº‹ä»¶"""
    
    logging.info(f">> bot is online  {bot.user.name} <<")
    
    if CHANNEL_ID:
        channel = bot.get_channel(int(CHANNEL_ID))
        if channel:
            await channel.send('æˆ‘ä¸Šç·šäº† æ±ª!')
        else:
            logging.warning(f"Channel ID {CHANNEL_ID} not found.")

    if UPTIME_KUMA_URL and not send_heartbeat.is_running():
        send_heartbeat.start()
        logging.info("Uptime Kuma heartbeat task started.")

    # âœ… --- åŒæ­¥ / æŒ‡ä»¤ ---
    try:
        # bot.tree.sync() æœƒè®€å–æ‰€æœ‰ hybrid_command ä¸¦è¨»å†Š (åŒ…æ‹¬ bot.py è‡ªå·±çš„)
        synced = await bot.tree.sync()
        logging.info(f"Synced {len(synced)} application (/) commands.")
    except Exception as e:
        logging.error(f"Failed to sync application commands: {e}")


# --- å…¨åŸŸéŒ¯èª¤è™•ç†å™¨ (æ•æ‰ CommandNotFound ç­‰) ---
@bot.event
async def on_command_error(ctx, error):
    """
    æ•æ‰æ‰€æœ‰æœªè¢« Cog è™•ç†çš„éŒ¯èª¤ (ä¾‹å¦‚ï¼šæŒ‡ä»¤æœªæ‰¾åˆ°)ã€‚
    """
    
    # 1. è™•ç†ã€ŒæŒ‡ä»¤æœªæ‰¾åˆ°ã€éŒ¯èª¤
    if isinstance(error, commands.CommandNotFound):
        logging.warning(
            f"æŒ‡ä»¤æœªæ‰¾åˆ° (CommandNotFound): {ctx.author} (ID: {ctx.author.id}) "
            f"åœ¨é »é“ #{ctx.channel.name} (Guild: {ctx.guild.name}) "
            f"å˜—è©¦ä½¿ç”¨: '{ctx.message.content}'"
        )
    
    # 2. è™•ç†ã€Œæ©Ÿå™¨äººæ“æœ‰è€…ã€æ¬Šé™éŒ¯èª¤ (é‡å° load/reload/restart)
    elif isinstance(error, commands.NotOwner):
        is_private = ctx.interaction is not None
        await ctx.send("âŒ **æ¬Šé™ä¸è¶³ï¼š** åªæœ‰æ©Ÿå™¨äººçš„æ“æœ‰è€…æ‰èƒ½ä½¿ç”¨æ­¤æŒ‡ä»¤ã€‚", ephemeral=is_private)

    # 3. è™•ç†å…¶ä»–æ‰€æœ‰æœªè¢« Cog æ•æ‰çš„ã€ŒçœŸæ­£ã€éŒ¯èª¤
    else:
        logging.error(
            f"æœªè™•ç†çš„å…¨åŸŸéŒ¯èª¤ (Unhandled Global Error)!\n"
            f"æŒ‡ä»¤: {ctx.command}\n"
            f"è§¸ç™¼è€…: {ctx.author} (ID: {ctx.author.id})\n"
            f"è¨Šæ¯: '{ctx.message.content}'\n"
            f"éŒ¯èª¤é¡å‹: {type(error).__name__}\n"
            f"éŒ¯èª¤è¨Šæ¯: {error}",
            exc_info=True # é™„åŠ å®Œæ•´çš„éŒ¯èª¤è¿½è¹¤ (Traceback)
        )
        try:
            # å˜—è©¦ä»¥ç§äººè¨Šæ¯å›è¦†ä½¿ç”¨è€…ç™¼ç”ŸéŒ¯èª¤
            if ctx.interaction and ctx.interaction.response.is_done():
                 await ctx.followup.send(f"âŒ ç™¼ç”Ÿäº†ä¸€å€‹æœªçŸ¥çš„å…§éƒ¨éŒ¯èª¤ï¼Œå·²é€šçŸ¥ç®¡ç†å“¡ã€‚", ephemeral=True)
            else:
                 await ctx.send(f"âŒ ç™¼ç”Ÿäº†ä¸€å€‹æœªçŸ¥çš„å…§éƒ¨éŒ¯èª¤ï¼Œå·²é€šçŸ¥ç®¡ç†å“¡ã€‚", ephemeral=True)
        except Exception as e:
            logging.error(f"Failed to send error message to user: {e}")


if __name__ == "__main__":
    # è¨­å®š logging çš„åŸºæœ¬é…ç½®
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

    # ç¢ºä¿ Token å­˜åœ¨å†å•Ÿå‹•
    if DISCORD_TOKEN:
        # åŠ è¼‰æ“´å±•æ¨¡çµ„
        asyncio.run(load_extensions(bot))
        # å•Ÿå‹•æ©Ÿå™¨äºº
        bot.run(DISCORD_TOKEN)
    else:
        logging.critical("Error: DISCORD_TOKEN not found in environment variables. Bot startup aborted.")
```

-----

### æª”æ¡ˆ 2ï¼š `cmds/image.py` (ç¶²è·¯åœ–ç‰‡)

(é€™æ˜¯ä¸€å€‹**æ–°æª”æ¡ˆ**ï¼Œè«‹å°‡å®ƒå„²å­˜åœ¨ `cmds` è³‡æ–™å¤¾ä¸­)

```python
import discord
from discord.ext import commands
from core.classes import Cog_Extension
import logging
from discord import app_commands
import requests # ç”¨æ–¼ç¶²è·¯åœ–ç‰‡
from io import BytesIO # ç”¨æ–¼ç¶²è·¯åœ–ç‰‡

class Image(Cog_Extension):
    
    # =========================================================
    # éŒ¯èª¤è™•ç† (Error Handler)
    # =========================================================
    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        
        # é—œéµä¿®æ­£ï¼šå¦‚æœæŒ‡ä»¤ä¸å±¬æ–¼ 'Image' Cogï¼Œå°±ç›´æ¥é€€å‡º
        if ctx.command and ctx.command.cog_name != 'Image':
            return
            
        logging.warning(f"Image Cog æ•ç²åˆ°æŒ‡ä»¤éŒ¯èª¤ (æŒ‡ä»¤: {ctx.command}, éŒ¯èª¤: {error})")
        is_private = ctx.interaction is not None
        
        if ctx.command and ctx.command.name == 'image':
            if isinstance(error, commands.MissingRequiredArgument):
                await ctx.send(f"âš ï¸ **åƒæ•¸éºæ¼éŒ¯èª¤ï¼š** æ‚¨å¿˜è¨˜æä¾› `keyword` (é—œéµå­—) åƒæ•¸äº†ï¼", ephemeral=is_private)
            else:
                pass # å…¶ä»–éŒ¯èª¤ä¸Šå ±çµ¦ bot.py

    # =========================================================
    # 1. æŒ‡ä»¤ï¼š#ç¶²è·¯åœ–ç‰‡
    # =========================================================
    @commands.hybrid_command(name="image", aliases=["img", "ç¶²è·¯åœ–ç‰‡"], description="å¾ Unsplash æœå°‹ä¸€å¼µéš¨æ©Ÿåœ–ç‰‡")
    @app_commands.describe(keyword="è¦æœå°‹çš„åœ–ç‰‡é—œéµå­— (å»ºè­°è‹±æ–‡)")
    async def image(self, ctx: commands.Context, *, keyword: str):
        
        is_private = ctx.interaction is not None
        
        # / æŒ‡ä»¤æœƒç”¨ "æ€è€ƒä¸­"ï¼Œ# æŒ‡ä»¤æœƒç™¼é€å…¬é–‹è¨Šæ¯
        msg = await ctx.send(f"ğŸ” æ­£åœ¨æœå°‹ã€Œ{keyword}ã€çš„åœ–ç‰‡...", ephemeral=is_private)

        try:
            url = f"https://source.unsplash.com/random/800x600?{keyword}"
            response = requests.get(url, timeout=10)
            response.raise_for_status() 

            image_file = discord.File(BytesIO(response.content), filename="image.jpg")
            
            embed = discord.Embed(
                title=f"é—œæ–¼ã€Œ{keyword}ã€çš„éš¨æ©Ÿåœ–ç‰‡",
                color=discord.Color.blue()
            )
            embed.set_image(url="attachment://image.jpg")
            
            if is_private:
                await ctx.followup.send(embed=embed, file=image_file, ephemeral=True)
            else:
                await msg.edit(content=None, embed=embed, attachments=[image_file])

        except requests.exceptions.HTTPError:
            error_msg = f"âŒ æ‰¾ä¸åˆ°é—œæ–¼ã€Œ{keyword}ã€çš„åœ–ç‰‡ï¼Œè«‹å˜—è©¦å…¶ä»–é—œéµå­—ã€‚"
            if is_private: await ctx.followup.send(error_msg, ephemeral=True)
            else: await msg.edit(content=error_msg)
        except Exception as e:
            error_msg = f"âŒ æœå°‹åœ–ç‰‡æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}"
            if is_private: await ctx.followup.send(error_msg, ephemeral=True)
            else: await msg.edit(content=error_msg)

async def setup(bot):
    await bot.add_cog(Image(bot))
```

-----

### æª”æ¡ˆ 3ï¼š `cmds/say.py` (å­¸æˆ‘)

(é€™æ˜¯ä¸€å€‹**æ–°æª”æ¡ˆ**ï¼Œè«‹å°‡å®ƒå„²å­˜åœ¨ `cmds` è³‡æ–™å¤¾ä¸­)

```python
import discord
from discord.ext import commands
from core.classes import Cog_Extension
import logging
from discord import app_commands

class Say(Cog_Extension):

    # =========================================================
    # éŒ¯èª¤è™•ç† (Error Handler)
    # =========================================================
    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        
        if ctx.command and ctx.command.cog_name != 'Say':
            return
            
        logging.warning(f"Say Cog æ•ç²åˆ°æŒ‡ä»¤éŒ¯èª¤ (æŒ‡ä»¤: {ctx.command}, éŒ¯èª¤: {error})")
        is_private = ctx.interaction is not None
        
        if ctx.command and ctx.command.name == 'say':
            if isinstance(error, commands.MissingRequiredArgument):
                await ctx.send(f"âš ï¸ **åƒæ•¸éºæ¼éŒ¯èª¤ï¼š** æ‚¨å¿˜è¨˜æä¾› `message` (è¨Šæ¯) åƒæ•¸äº†ï¼", ephemeral=is_private)
            else:
                pass # å…¶ä»–éŒ¯èª¤ä¸Šå ±çµ¦ bot.py

    # =========================================================
    # 2. æŒ‡ä»¤ï¼š#å­¸æˆ‘
    # =========================================================
    @commands.hybrid_command(name="say", aliases=["echo", "å­¸æˆ‘"], description="è®“æ©Ÿå™¨äººèªªå‡ºä½ æƒ³èªªçš„è©±")
    @app_commands.describe(message="è¦è®“æ©Ÿå™¨äººèªªçš„è©±")
    async def say(self, ctx: commands.Context, *, message: str):
        
        is_private = ctx.interaction is not None
        
        if not is_private:
            # å¦‚æœæ˜¯ # æŒ‡ä»¤ï¼Œå˜—è©¦åˆªé™¤åŸå§‹æŒ‡ä»¤è¨Šæ¯
            try:
                await ctx.message.delete()
            except discord.Forbidden:
                pass # æ¬Šé™ä¸è¶³ä¹Ÿæ²’é—œä¿‚
        
        # / æŒ‡ä»¤ï¼šç§äººå›è¦†
        # # æŒ‡ä»¤ï¼šå…¬é–‹å›è¦†
        await ctx.send(message, ephemeral=is_private)


async def setup(bot):
    await bot.add_cog(Say(bot))
```

-----

### æª”æ¡ˆ 4ï¼š `cmds/ids.py` (ID æŸ¥è©¢)

(é€™æ˜¯ä¸€å€‹**æ–°æª”æ¡ˆ**ï¼Œè«‹å°‡å®ƒå„²å­˜åœ¨ `cmds` è³‡æ–™å¤¾ä¸­)

```python
import discord
from discord.ext import commands
from core.classes import Cog_Extension
import logging
from discord import app_commands

class IDs(Cog_Extension):

    # =========================================================
    # éŒ¯èª¤è™•ç† (Error Handler)
    # =========================================================
    @commands.Cog.listener()
    async def on_command_error(self, ctx, error):
        
        if ctx.command and ctx.command.cog_name != 'IDs':
            return
            
        logging.warning(f"IDs Cog æ•ç²åˆ°æŒ‡ä»¤éŒ¯èª¤ (æŒ‡ä»¤: {ctx.command}, éŒ¯èª¤: {error})")
        # (æ­¤æŒ‡ä»¤ç„¡åƒæ•¸ï¼Œå› æ­¤é€šå¸¸ä¸æœƒè§¸ç™¼ MissingRequiredArgument)
        pass # æ‰€æœ‰éŒ¯èª¤éƒ½ä¸Šå ±çµ¦ bot.py

    # =========================================================
    # 3. æŒ‡ä»¤ï¼š#all_id
    # =========================================================
    @commands.hybrid_command(name="ids", aliases=["all_id"], description="é¡¯ç¤ºæ‰€æœ‰ç›¸é—œçš„ ID")
    async def ids(self, ctx: commands.Context):
        is_private = ctx.interaction is not None
        
        embed = discord.Embed(title="è³‡è¨Š ID æ¸…å–®", color=discord.Color.blue())
        embed.add_field(name="æ‚¨çš„ ID", value=f"`{ctx.author.id}`", inline=False)
        embed.add_field(name="æ­¤é »é“ ID", value=f"`{ctx.channel.id}`", inline=False)
        
        if ctx.guild:
            embed.add_field(name="æ­¤ä¼ºæœå™¨ ID", value=f"`{ctx.guild.id}`", inline=False)
        
        await ctx.send(embed=embed, ephemeral=is_private)


async def setup(bot):
    await bot.add_cog(IDs(bot))
```